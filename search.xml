<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基础数据结构·数组</title>
      <link href="/posts/cb785ee8.html"/>
      <url>/posts/cb785ee8.html</url>
      
        <content type="html"><![CDATA[<h1>基础数据结构</h1><h2 id="数组">数组</h2><h3 id="概述">概述</h3><p><strong>定义</strong></p><p>在计算机科学中，数组是由一组元素（值或变量）组成的数据结构，每个元素有至少一个索引或键来标识</p><blockquote><p>In computer science, an <strong>array</strong> is a data structure consisting of a collection of <em>elements</em> (values or variables), each identified by at least one <em>array index</em> or <em>key</em></p></blockquote><p>因为数组内的元素是<strong>连续存储</strong>的，所以数组中元素的地址，可以通过其索引计算出来，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>知道了数组的<strong>数据</strong>起始地址 $BaseAddress$，就可以由公式 $BaseAddress + i * size$ 计算出索引 $i$ 元素的地址</p><ul><li>$i$ 即索引，在 Java、C 等语言都是从 0 开始</li><li>$size$ 是每个元素占用字节，例如 $int$ 占 $4$，$double$ 占 $8$</li></ul><p><strong>小测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>已知 array 的<strong>数据</strong>的起始地址是 0x7138f94c8，那么元素 3 的地址是什么？</p><blockquote><p>答：0x7138f94c8 + 2 * 1 = 0x7138f94ca</p></blockquote><p><strong>空间占用</strong></p><p>Java 中数组结构为</p><ul><li>8 字节 markword</li><li>4 字节 class 指针（压缩 class 指针的情况）</li><li>4 字节 数组大小（决定了数组最大容量是 $2^{32}$）</li><li>数组元素 + 对齐字节（java 中所有对象大小都是 8 字节的整数倍[^12]，不足的要用对齐字节补足）</li></ul><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>的大小为 40 个字节，组成如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 + 4 + 4 + 5*4 + 4(alignment)</span><br></pre></td></tr></table></figure><p><strong>随机访问性能</strong></p><p>即根据索引查找元素，时间复杂度是 $O(1)$</p><h3 id="动态数组">动态数组</h3><p><strong>java 版本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicArray</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 逻辑大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">8</span>; <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向最后位置 [size] 添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 待添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line">        add(size, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向 [0 .. size] 位置添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index   索引位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 待添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">        checkAndGrow();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size) &#123;</span><br><span class="line">            <span class="comment">// 向后挪动, 空出待插入位置</span></span><br><span class="line">            System.arraycopy(array, index,</span><br><span class="line">                    array, index + <span class="number">1</span>, size - index);</span><br><span class="line">        &#125;</span><br><span class="line">        array[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkAndGrow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 容量检查</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            array = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            <span class="comment">// 进行扩容, 1.5 1.618 2</span></span><br><span class="line">            capacity += capacity &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">            System.arraycopy(array, <span class="number">0</span>,</span><br><span class="line">                    newArray, <span class="number">0</span>, size);</span><br><span class="line">            array = newArray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 [0 .. size) 范围删除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">// [0..size)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">removed</span> <span class="operator">=</span> array[index];</span><br><span class="line">        <span class="keyword">if</span> (index &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向前挪动</span></span><br><span class="line">            System.arraycopy(array, index + <span class="number">1</span>,</span><br><span class="line">                    array, index, size - index - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引位置, 在 [0..size) 区间内</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该索引位置的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历方法1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer 遍历要执行的操作, 入参: 每个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foreach</span><span class="params">(Consumer&lt;Integer&gt; consumer)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// 提供 array[i]</span></span><br><span class="line">            <span class="comment">// 返回 void</span></span><br><span class="line">            consumer.accept(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历方法2 - 迭代器遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123; <span class="comment">// 有没有下一个元素</span></span><br><span class="line">                <span class="keyword">return</span> i &lt; size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123; <span class="comment">// 返回当前元素,并移动到下一个元素</span></span><br><span class="line">                <span class="keyword">return</span> array[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历方法3 - stream 遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> stream 流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> IntStream <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.of(Arrays.copyOfRange(array, <span class="number">0</span>, size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这些方法实现，都简化了 index 的有效性判断，假设输入的 index 都是合法的</li></ul><p><strong>插入或删除性能</strong></p><p>头部位置，时间复杂度是 $O(n)$</p><p>中间位置，时间复杂度是 $O(n)$</p><p>尾部位置，时间复杂度是 $O(1)$（均摊来说）</p>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门·二分查找及其时间复杂度</title>
      <link href="/posts/4729e793.html"/>
      <url>/posts/4729e793.html</url>
      
        <content type="html"><![CDATA[<h1>初识算法</h1><h2 id="1-1-什么是算法？">1.1 什么是算法？</h2><p><strong>定义</strong></p><p>在数学和计算机科学领域，算法是一系列有限的严谨指令，通常用于解决一类特定问题或执行计算</p><blockquote><p>In mathematics and computer science, an <strong>algorithm</strong> (/ˈælɡərɪðəm/) is a finite sequence of rigorous instructions, typically used to solve a class of specific problems or to perform a computation.<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p></blockquote><p><strong>Introduction to Algorithm<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></strong></p><p>不正式的说，算法就是任何定义优良的计算过程：接收一些值作为输入，在有限的时间内，产生一些值作为输出。</p><blockquote><p>Informally, an algorithm is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time.</p></blockquote><h2 id="1-2-什么是数据结构？">1.2 什么是数据结构？</h2><p><strong>定义</strong></p><p>在计算机科学领域，数据结构是一种数据组织、管理和存储格式，通常被选择用来高效访问数据</p><blockquote><p>In computer science, a <strong>data structure</strong> is a data organization, management, and storage format that is usually chosen for efficient access to data</p></blockquote><p><strong>Introduction to Algorithm<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup></strong></p><p>数据结构是一种存储和组织数据的方式，旨在便于访问和修改</p><blockquote><p>A data structure is a way to store and organize data in order to facilitate access and modifications</p></blockquote><p>接下来我们通过对一个非常著名的二分查找算法的讲解来认识一下算法</p><h2 id="1-3-二分查找">1.3 二分查找 <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></h2><p>二分查找算法也称折半查找，是一种非常高效的工作于有序数组的查找算法。后续的课程中还会学习更多的查找算法，但在此之前，不妨用它作为入门。</p><h3 id="二分查找基础版">二分查找基础版</h3><p>需求：在<strong>有序</strong>数组 $A$ 内，查找值 $target$</p><ul><li>如果找到返回索引</li><li>如果找不到返回 $-1$</li></ul><table><thead><tr><th>算法描述</th><th></th></tr></thead><tbody><tr><td>前提</td><td>给定一个内含 $n$ 个元素的有序数组 $A$，满足 $A_{0}\leq A_{1}\leq A_{2}\leq \cdots \leq A_{n-1}$，一个待查值 $target$</td></tr><tr><td>1</td><td>设置 $i=0$，$j=n-1$</td></tr><tr><td>2</td><td>如果 $i \gt j$，结束查找，没找到</td></tr><tr><td>3</td><td>设置 $m = floor(\frac {i+j}{2})$ ，$m$ 为中间索引，$floor$ 是向下取整（$\leq \frac {i+j}{2}$ 的最小整数）</td></tr><tr><td>4</td><td>如果 $target &lt; A_{m}$ 设置 $j = m - 1$，跳到第2步</td></tr><tr><td>5</td><td>如果 $A_{m} &lt; target$ 设置 $i = m + 1$，跳到第2步</td></tr><tr><td>6</td><td>如果 $A_{m} = target$，结束查找，找到了</td></tr></tbody></table><p>java 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;<span class="comment">// 在左边</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123;<span class="comment">// 在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$i,j$ 对应着搜索区间 $[0,a.length-1]$（注意是闭合的区间），$i&lt;=j$ 意味着搜索区间内还有未比较的元素，$i,j$ 指向的元素也可能是比较的目标<ul><li>思考：如果不加 $i==j$ 行不行？</li><li>回答：不行，因为这意味着 $i,j$ 指向的元素会漏过比较</li></ul></li><li>$m$ 对应着中间位置，中间位置左边和右边的元素可能不相等（差一个），不会影响结果</li><li>如果某次未找到，那么缩小后的区间内不包含 $m$</li></ul><h3 id="二分查找改变版">二分查找改变版</h3><p>另一种写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;<span class="comment">// 在左边</span></span><br><span class="line">            j = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123;<span class="comment">// 在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$i,j$ 对应着搜索区间 $[0,a.length)$（注意是左闭右开的区间），$i&lt;j$ 意味着搜索区间内还有未比较的元素，$j$ 指向的<strong>一定不是</strong>查找目标<ul><li>思考：为啥这次不加 $i==j$ 的条件了？</li><li>回答：这回 $j$ 指向的不是查找目标，如果还加 $i==j$ 条件，就意味着 $j$ 指向的还会再次比较，找不到时，会死循环</li></ul></li><li>如果某次要缩小右边界，那么 $j=m$，因为此时的 $m$ 已经<strong>不是</strong>查找目标了</li></ul><h3 id="衡量算法好坏">衡量算法好坏</h3><p><strong>时间复杂度</strong></p><p>下面的查找算法也能得出与之前二分查找一样的结果，我们来看看它们有什么区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        i &lt; a.length;</span><br><span class="line">        i++</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑最坏情况下（没找到）例如 <code>[1,2,3,4]</code> 查找 5</p><ul><li><code>int i = 0</code> 只执行一次</li><li><code>i &lt; a.length</code> 受数组元素个数 $n$ 的影响，比较 $n+1$ 次</li><li><code>i++</code> 受数组元素个数 $n$ 的影响，自增 $n$ 次</li><li><code>a[i] == k</code> 受元素个数 $n$ 的影响，比较 $n$ 次</li><li><code>return -1</code>，执行一次</li></ul><p>粗略认为每行代码执行时间是 $t$，假设 $n=4$ 那么</p><ul><li>总执行时间是 $(1+4+1+4+4+1)*t = 15t$</li><li>可以推导出更一般地公式为，$T = (3*n+3)t$</li></ul><p>如果套用二分查找算法，还是 <code>[1,2,3,4]</code> 查找 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;<span class="comment">// 在左边</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123;<span class="comment">// 在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>int i = 0, j = a.length - 1</code> 各执行 1 次</p></li><li><p><code>i &lt;= j</code> 比较 $floor(\log_{2}(n)+1)$ 再加 1 次</p></li><li><p><code>(i + j) &gt;&gt;&gt; 1</code> 计算 $floor(\log_{2}(n)+1)$ 次</p></li><li><p>接下来 <code>if() else if() else</code> 会执行 $3* floor(\log_{2}(n)+1)$ 次，分别为</p><ul><li>if 比较</li><li>else if 比较</li><li>else if 比较成立后的赋值语句</li></ul></li><li><p><code>return -1</code>，执行一次</p></li></ul><p>结果：</p><ul><li>总执行时间为 $(2 + (1+3) + 3 + 3 * 3 +1)*t = 19t$</li><li>更一般地公式为 $(4 + 5 * floor(\log_{2}(n)+1))*t$</li></ul><blockquote><p><strong>注意：</strong></p><p>左侧未找到和右侧未找到结果不一样，这里不做分析</p></blockquote><p>两个算法比较，可以看到 $n$ 在较小的时候，二者花费的次数差不多</p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202306011301286.png" alt="image-20221108095747933" style="zoom:50%;" /><p>但随着 $n$ 越来越大，比如说 $n=1000$ 时，用二分查找算法（红色）也就是 $54t$，而蓝色算法则需要 $3003t$</p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202306011301150.png" alt="image-20221108100014451" style="zoom:50%;" /><blockquote><p>画图采用的是 <a href="https://www.desmos.com/calculator?lang=zh-CN">Desmos | 图形计算器</a></p></blockquote><p>计算机科学中，<strong>时间复杂度</strong>是用来衡量：一个算法的执行，随数据规模增大，而增长的时间成本</p><ul><li>不依赖于环境因素</li></ul><p>如何表示时间复杂度呢？</p><ul><li><p>假设算法要处理的数据规模是 $n$，代码总的执行行数用函数 $f(n)$ 来表示，例如：</p><ul><li>线性查找算法的函数 $f(n) = 3*n + 3$</li><li>二分查找算法的函数 $f(n) = (floor(log_2(n)) + 1) * 5 + 4$</li></ul></li><li><p>为了对 $f(n)$ 进行化简，应当抓住主要矛盾，找到一个变化趋势与之相近的表示法</p></li></ul><p><strong>大 $O$ 表示法[^4]</strong></p><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202306011301662.png" alt="image-20221108103846566"></p><p>其中</p><ul><li>$c, c_1, c_2$ 都为一个常数</li><li>$f(n)$ 是实际执行代码行数与 n 的函数</li><li>$g(n)$ 是经过化简，变化趋势与 $f(n)$ 一致的 n 的函数</li></ul><p><strong>渐进上界</strong></p><p>渐进上界（asymptotic upper bound）：从某个常数 $n_0$开始，$c*g(n)$ 总是位于 $f(n)$ 上方，那么记作 $O(g(n))$</p><ul><li>代表算法执行的最差情况</li></ul><p>例1</p><ul><li>$f(n) = 3*n+3$</li><li>$g(n) = n$</li><li>取 $c=4$，在$n_0=3$ 之后，$g(n)$ 可以作为 $f(n)$ 的渐进上界，因此表示法写作 $O(n)$</li></ul><p>例2</p><ul><li>$f(n) = 5*floor(log_2(n)) + 9$</li><li>$g(n) = log_2(n)$</li><li>$O(log_2(n))$</li></ul><p>已知 $f(n)$ 来说，求 $g(n)$</p><ul><li>表达式中相乘的常量，可以省略，如<ul><li>$f(n) = 100*n^2$ 中的 $100$</li></ul></li><li>多项式中数量规模更小（低次项）的表达式，如<ul><li>$f(n)=n^2+n$ 中的 $n$</li><li>$f(n) = n^3 + n^2$ 中的 $n^2$</li></ul></li><li>不同底数的对数，渐进上界可以用一个对数函数 $\log n$ 表示<ul><li>例如：$log_2(n)$ 可以替换为 $log_{10}(n)$，因为 $log_2(n) = \frac{log_{10}(n)}{log_{10}(2)}$，相乘的常量 $\frac{1}{log_{10}(2)}$ 可以省略</li></ul></li><li>类似的，对数的常数次幂可省略<ul><li>如：$log(n^c) = c * log(n)$</li></ul></li></ul><p><strong>常见大 $O$ 表示法</strong></p><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202306011301584.png" alt="image-20221108114915524"></p><p>按时间复杂度从低到高</p><ul><li>黑色横线 $O(1)$，常量时间，意味着算法时间并不随数据规模而变化</li><li>绿色 $O(log(n))$，对数时间</li><li>蓝色 $O(n)$，线性时间，算法时间与数据规模成正比</li><li>橙色 $O(n*log(n))$，拟线性时间</li><li>红色 $O(n^2)$ 平方时间</li><li>黑色朝上 $O(2^n)$ 指数时间</li><li>没画出来的 $O(n!)$</li></ul><p><strong>渐进下界</strong></p><p>渐进下界（asymptotic lower bound）：从某个常数 $n_0$开始，$c*g(n)$ 总是位于 $f(n)$ 下方，那么记作 $\Omega(g(n))$</p><p><strong>渐进紧界</strong></p><p>渐进紧界（asymptotic tight bounds）：从某个常数 $n_0$开始，$f(n)$ 总是在 $c_1<em>g(n)$ 和 $c_2</em>g(n)$ 之间，那么记作 $\Theta(g(n))$</p><p><strong>空间复杂度</strong></p><p>与时间复杂度类似，一般也使用大 $O$ 表示法来衡量：一个算法执行随数据规模增大，而增长的<strong>额外</strong>空间成本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchBasic</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;    <span class="comment">// 设置指针和初值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;                <span class="comment">// i~j 范围内有东西</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; a[m]) &#123;         <span class="comment">// 目标在左边</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123; <span class="comment">// 目标在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 找到了</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分查找性能</strong></p><p>下面分析二分查找算法的性能</p><p>时间复杂度</p><ul><li>最坏情况：$O(\log n)$</li><li>最好情况：如果待查找元素恰好在数组中央，只需要循环一次 $O(1)$</li></ul><p>空间复杂度</p><ul><li>需要常数个指针 $i,j,m$，因此额外占用的空间是 $O(1)$</li></ul><h3 id="二分查找平衡版">二分查找平衡版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchBalance</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span> &lt; j - i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;</span><br><span class="line">            j = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (a[i] == target) ? i : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思想：</p><ol><li>左闭右开的区间，$i$ 指向的可能是目标，而 $j$ 指向的不是目标</li><li>不奢望循环内通过 $m$ 找出目标, 缩小区间直至剩 1 个, 剩下的这个可能就是要找的（通过 $i$）<ul><li>$j - i &gt; 1$ 的含义是，在范围内待比较的元素个数 &gt; 1</li></ul></li><li>改变 $i$ 边界时，它指向的可能是目标，因此不能 $m+1$</li><li>循环内的平均比较次数减少了</li><li>时间复杂度 $\Theta(log(n))$</li></ol><h3 id="二分查找-Java-版">二分查找 Java 版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch0</span><span class="params">(<span class="type">long</span>[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex,</span></span><br><span class="line"><span class="params">                                     <span class="type">long</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> fromIndex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> toIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">midVal</span> <span class="operator">=</span> a[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; key)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>例如 $[1,3,5,6]$ 要插入 $2$ 那么就是找到一个位置，这个位置左侧元素都比它小<ul><li>等循环结束，若没找到，low 左侧元素肯定都比 target 小，因此 low 即插入点</li></ul></li><li>插入点取负是为了与找到情况区分</li><li>-1 是为了把索引 0 位置的插入点与找到的情况进行区分</li></ul><h3 id="Leftmost-与-Rightmost">Leftmost 与 Rightmost</h3><p>有时我们希望返回的是最左侧的重复元素，如果用 Basic 二分查找</p><ul><li><p>对于数组 $[1, 2, 3, 4, 4, 5, 6, 7]$，查找元素4，结果是索引3</p></li><li><p>对于数组 $[1, 2, 4, 4, 4, 5, 6, 7]$，查找元素4，结果也是索引3，并不是最左侧的元素</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchLeftmost1</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            candidate = m; <span class="comment">// 记录候选位置</span></span><br><span class="line">            j = m - <span class="number">1</span>;     <span class="comment">// 继续向左</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望返回的是最右侧元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchRightmost1</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            candidate = m; <span class="comment">// 记录候选位置</span></span><br><span class="line">            i = m + <span class="number">1</span>;   <span class="comment">// 继续向右</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用</strong></p><p>对于 Leftmost 与 Rightmost，可以返回一个比 -1 更有用的值</p><p>Leftmost 改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchLeftmost</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= a[m]) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>leftmost 返回值的另一层含义：$\lt target$ 的元素个数</li><li>小于等于中间值，都要向左找</li></ul><p>Rightmost 改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchRightmost</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>大于等于中间值，都要向右找</li></ul><p>几个名词</p><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202306011302337.png" alt="image-20221125174155058"></p><p><strong>范围查询</strong>：</p><ul><li>查询 $x \lt 4$，$0 … leftmost(4) - 1$</li><li>查询 $x \leq 4$，$0 … rightmost(4)$</li><li>查询 $4 \lt x$，$rightmost(4) + 1 … \infty $</li><li>查询 $4 \leq x$， $leftmost(4) … \infty$</li><li>查询 $4 \leq x \leq 7$，$leftmost(4) … rightmost(7)$</li><li>查询 $4 \lt x \lt 7$，$rightmost(4)+1 … leftmost(7)-1$</li></ul><p><strong>求排名</strong>：$leftmost(target) + 1$</p><ul><li>$target$ 可以不存在，如：$leftmost(5)+1 = 6$</li><li>$target$ 也可以存在，如：$leftmost(4)+1 = 3$</li></ul><p><strong>求前任（predecessor）</strong>：$leftmost(target) - 1$</p><ul><li>$leftmost(3) - 1 = 1$，前任 $a_1 = 2$</li><li>$leftmost(4) - 1 = 1$，前任 $a_1 = 2$</li></ul><p><strong>求后任（successor）</strong>：$rightmost(target)+1$</p><ul><li>$rightmost(5) + 1 = 5$，后任 $a_5 = 7$</li><li>$rightmost(4) + 1 = 5$，后任 $a_5 = 7$</li></ul><p><strong>求最近邻居</strong>：</p><ul><li>前任和后任距离更近者</li></ul><h1>附录</h1><h2 id="参考文章">参考文章</h2><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.merriam-webster.com/dictionary/algorithm">“Definition of ALGORITHM”</a>. <em>Merriam-Webster Online Dictionary</em>. <a href="https://web.archive.org/web/20200214074446/https://www.merriam-webster.com/dictionary/algorithm">Archived</a> from the original on February 14, 2020. Retrieved November 14, 2019. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>Introduction to Algorithm 中文译作《算法导论》 <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>主要参考文档 https://en.wikipedia.org/wiki/Binary_search_algorithm <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基本使用</title>
      <link href="/posts/2df4f2b8.html"/>
      <url>/posts/2df4f2b8.html</url>
      
        <content type="html"><![CDATA[<h1><strong>Git基础入门</strong></h1><h2 id="一、Git原理简要"><strong>一、Git原理简要</strong></h2><p>4个区域</p><p>Workspace：工作区 Stage：暂存区 Repository：本地仓库 Remote：远程仓库</p><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202305201713519.png" alt="basic-usage.svg"></p><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202305201713154.png" alt="basic-usage-2.svg"></p><h3 id="1-下载与安装"><strong>1.下载与安装:</strong></h3><p>https://git-scm.com/download/</p><h3 id="2-使用入口"><strong>2.使用入口</strong></h3><p>win：右键菜单—git bash</p><p>mac：终端窗口</p><h3 id="3-基础配置"><strong>3.基础配置</strong></h3><p>首次使用添加身份说明，使用以下两个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;你的昵称&quot;</span></span><br><span class="line"></span><br><span class="line">$ git config --global user.email 邮箱@example.com</span><br></pre></td></tr></table></figure><p>创建仓库</p><p>① 在项目文件夹下使用git bash输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>② 使用他人项目创建仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> 项目url</span><br></pre></td></tr></table></figure><h2 id="二、状态与提交版本"><strong>二、状态与提交版本</strong></h2><p>文件四种状态</p><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202305201713561.png" alt="image-20230502111811562"></p><h3 id="1-跟踪">1.跟踪</h3><p>跟踪文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add &lt;name&gt;</span><br></pre></td></tr></table></figure><p>跟踪当前目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure><h3 id="2-取消跟踪">2.取消跟踪</h3><p>rm删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">rm</span> &lt;name&gt;</span><br></pre></td></tr></table></figure><p>保留但不跟踪</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm-cache &lt;name&gt;</span><br></pre></td></tr></table></figure><h3 id="3-文件状态修改">3.文件状态修改</h3><p>修改后缓存 / 取消缓存</p><p>将修改文件缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add &lt;file-name&gt;</span><br></pre></td></tr></table></figure><p>取消缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD &lt;name&gt;</span><br></pre></td></tr></table></figure><p>提交缓存的修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;本次提交描述&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-git-commit-具体操作">4.$ git commit 具体操作</h3><p>① $ git commit 进入提交界面,</p><p>​    按&quot; i &quot;键进入输入模式后输入本次提交详情,</p><p>​    然后esc退出编辑模式, 按&quot; : &quot;进入命令栏, 输入&quot;wq&quot;保存并退出.</p><p>② $ git commit -m ’ 你对提交内容的描述 ’</p><p>③ $ git commit -a</p><p>​    连带未暂存文件一起提交</p><p>​    git commit -am ‘提交描述’</p><h2 id="三、远程仓库"><strong>三、远程仓库</strong></h2><p>新建远程仓库</p><h3 id="1-链接远程仓库到本地"><strong>1.链接远程仓库到本地</strong></h3><p>本地添加远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin 远程仓库链接</span><br></pre></td></tr></table></figure><h3 id="2-重命名仓库"><strong>2.重命名仓库</strong></h3><p>查看远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br></pre></td></tr></table></figure><p>修改远程仓库名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename &lt;name&gt; &lt;new name&gt;</span><br></pre></td></tr></table></figure><h3 id="3-推送本地代码到远程仓库"><strong>3.推送本地代码到远程仓库</strong></h3><p>推送</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push 仓库名 分支名</span><br></pre></td></tr></table></figure><h3 id="4-验证">4.验证</h3><p>①使用token令牌验证</p><p>②简单方式:SSH鉴权</p><h2 id="四、分支"><strong>四、分支</strong></h2><h3 id="1-分支的概念"><strong>1.分支的概念</strong></h3><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202305201713467.png" alt="image-20230502114331064"></p><p><strong>每次提交时会生成一个提交对象，每个提交对象有独一无二的哈希值，分支就是一个包含该哈希值的文件</strong></p><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202305201713821.png" alt="image-20230502114425973"></p><p><strong>可以理解为分支就是某次提交的一个指针，可以在一个提交对象上新建多个分支</strong></p><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202305201713972.png" alt="image-20230502114643286"></p><p><strong>初始化本地仓库时就会新建一个master分支</strong></p><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202305201714925.png" alt="image-20230502114845388"></p><p><strong>每次进行一次提交时，分支也会跟着提交对象向前移动</strong></p><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202305201714195.png" alt="image-20230502115127464"></p><p><strong>在第二次提交对象上新建一个分支</strong></p><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202305201713789.png" alt="image-20230502115345401"></p><p><strong>之后的提交就会有不同的分支</strong></p><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202305201714633.png" alt="image-20230502115507549"></p><h3 id="2-经典git模型"><strong>2.经典git模型</strong></h3><p><img src="https://doido-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/202305201714264.png" alt="image-20230502115831722"></p><h3 id="3-分支操作"><strong>3.分支操作</strong></h3><h4 id="创建分支名">创建分支名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch 分支名</span><br></pre></td></tr></table></figure><h4 id="查看分支名">查看分支名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --list</span><br></pre></td></tr></table></figure><h4 id="切换分支"><strong>切换分支</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 分支名</span><br></pre></td></tr></table></figure><h2 id="五、分支合并"><strong>五、分支合并</strong></h2><h3 id="1-无冲突合并"><strong>1.无冲突合并</strong></h3><p>在 合并至 的分支使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge 要合并的分支</span><br></pre></td></tr></table></figure><h3 id="2-分支冲突-merge-conflict"><strong>2.分支冲突 merge conflict</strong></h3><p>将 分支2 合并到 master分支 时, 与 分支1 冲突了. 原因是 分支1 和 分支2 修改了同一处内容.</p><p>查看哪里有冲突</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status </span><br></pre></td></tr></table></figure><p>$ vi 到冲突文件中, 选择一个分支的内容保留下来, 保存退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add 文件名</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;提交描述&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --all --graph 查看合并状态</span><br></pre></td></tr></table></figure><h2 id="六、推拉与远程跟踪分支"><strong>六、推拉与远程跟踪分支</strong></h2><h3 id="1-推送"><strong>1.推送</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push 仓库名 分支名</span><br></pre></td></tr></table></figure><p><strong>或者</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u 仓库名 分支名</span><br></pre></td></tr></table></figure><p><strong>第一次使用 -u 指定推送目标后, 此后可直接使用git push</strong></p><h3 id="2-拉取"><strong>2.拉取</strong></h3><p>$ git fetch</p><p>$ git checkout 远程分支</p><p>$ git checkout -b 本地分支名 远程分支</p><p>$ git checkout --track 远程分支</p><h2 id="七、贮藏功能"><strong>七、贮藏功能</strong></h2><p><strong>1.git stash</strong></p><p>代码写到一半有13事儿来了, 要切换到其他分支是不允许的, 可以把当前分支修改的东西储藏起来再切换.</p><p><strong>2.git stash apply</strong></p><p>切换回来后, 恢复之前存储的内容</p><p><strong>3.多次存储</strong></p><p>a.回看存储记录</p><p>$ git stash list</p><p>b.恢复指定记录</p><p>$ git stash apply stash@{记录号}</p><p>c.恢复并删除记录</p><p>①恢复并删除最近一次记录</p><p>$ git stash pop</p><p>②<strong>删除</strong>指定记录</p><p>$ git stash drop @stash{记录号}</p><h2 id="八、重置与变基"><strong>八、重置与变基</strong></h2><p><strong>1.reset(重置)</strong></p><p>a. head</p><p>head: 当前的提交</p><p>head~: 上次的提交</p><p>head~2: 倒数第二次的提交</p><p>b. --soft</p><p>仅取消commit操作, 把修改文件暂存.</p><p>如果不加 --soft 则表示恢复到暂存前, 修改的内容是存在的.</p><p>c. --hard</p><p>取消暂存, 还取消修改内容, 彻底回到上次提交的状态.</p><p>不推荐使用, 可能丢失数据.</p><p><strong>2.rebase(变基)</strong></p><p>a.将B分支的修改移动到A分支</p><p>git checkout B</p><p>git rebase A</p><p>b.注意事项</p><p>注意他人在远程分支二次开发时, 审慎使用变基</p>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
